import 'dart:async';
import 'dart:convert';
import 'dart:io';
// import 'dart:math';
import 'package:evidya/main.dart';
import 'package:evidya/model/chat_model.dart';
import 'package:evidya/screens/messenger/calls/audiocallscreen.dart';
import 'package:evidya/screens/messenger/calls/videocallscreen.dart';
import 'package:evidya/sharedpref/preference_connector.dart';
import 'package:evidya/screens/messenger/fullscreenimage.dart';
import 'package:evidya/screens/messenger/pdfviewer.dart';
import 'package:file_picker/file_picker.dart';

import 'package:evidya/constants/color_constant.dart';
import 'package:evidya/constants/string_constant.dart';
import 'package:evidya/network/repository/api_repository.dart';

import 'package:evidya/screens/bottom_navigation/bottom_navigaction_bar.dart';
import 'package:evidya/screens/messenger/sender_profile_page.dart';
import 'package:flutter/services.dart';

import 'package:flutter_easyloading/flutter_easyloading.dart';
import 'package:agora_rtm/agora_rtm.dart';
import 'package:cached_network_image/cached_network_image.dart';
import 'package:evidya/localdb/databasehelper.dart';
import 'package:evidya/model/login/autogenerated.dart';
import 'package:evidya/model/login/contactsmatch_Modal.dart';
import 'package:evidya/model/recentchatconnectionslist_modal.dart';
import 'package:evidya/resources/app_colors.dart';
import 'package:evidya/utils/helper.dart';
import 'package:flutter/material.dart';
import 'package:flutter_svg/svg.dart';
import 'package:image_picker/image_picker.dart';
import 'package:intl/intl.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:sizer/sizer.dart';
import 'package:swipe_to/swipe_to.dart';
import 'package:video_player/video_player.dart';
import '../../notificationservice/LocalNotificationService.dart';
import '../../widget/gradient_bg_view.dart';
import 'chatscreenutils.dart';
import 'msgvideoplayer.dart';
import 'onlinestatus.dart';

class Chat_Screen extends StatefulWidget {
  static String onlinestatus = 'Offline';

  final AgoraRtmClient client;
  // final AgoraRtmChannel channel;
  final String rtmpeerid;
  // final LogController logController;
  // final MessageLog messagePeerId;
  final Contacts userdetails;
  final Connections recentchatuserdetails;
  final List<Connections> userlist;
  final String status;

  const Chat_Screen(
      {Key key,
      this.client,
      // this.channel,
      // this.logController,
      this.userdetails,
      // this.messagePeerId,
      this.rtmpeerid,
      this.recentchatuserdetails,
      this.status,
      this.userlist})
      : super(key: key);

  @override
  _Chat_ScreenState createState() => _Chat_ScreenState();
}

class _Chat_ScreenState extends State<Chat_Screen> {
  final _peerMessage = TextEditingController();
  final ScrollController _controller = ScrollController();
  // VideoPlayerController _videoPlayerController;
  String _replytex = '';
  String _replyImagePath = '';
  bool _replyVisibility = false;
  final _dbHelper = DatabaseHelper.instance;
  final _picker = ImagePicker();
  RegExp fileExp = RegExp(r'([/|.|\w|\s|-])*\.(?:jpg|gif|png|jpeg)');
  bool _afile = false;
  LocalDataModal _loginData;
  String _userpeerid;

  String _recieptPerson;
  // String _enteredText = '';
  bool _isInputBoxEmpty = true;
  String _devicefcmtoken;
  int _length = 0;
  bool _loading = false;
  var _uplordstatus = 0;
  final List<bool> _seleteduserlist = [];

  AgoraRtmClient _client;
  bool _sendingMessage = false;
  // AnimationController _animController;

  @override
  void initState() {
    Chat_Screen.onlinestatus = 'Offline';
    // _videoPlayerController = VideoPlayerController.network();

    PreferenceConnector().setCurrentChatUserName(
      widget.recentchatuserdetails.name,
    );
    queryRowCount();
    localdata();
    super.initState();

    _recieptPerson = widget.recentchatuserdetails.name;
    final code = widget.rtmpeerid.hashCode;
    LocalNotificationService.clearPool(code);

    if (widget.client != null) {
      _client = widget.client;
    } else {
      _createClient();
    }
    // getDeviceTokenToSendNotification();
  }

  /// this fun call on deleting a msg from sqlfite localdata
  void _delete(msgid, index) async {
    chatLogController.removeLog(index);
    _dbHelper.delete(msgid);
  }

  /// getting sqflite localdata for chat history.
  void queryRowCount() async {
    final value =
        await PreferenceConnector.getJsonToSharedPreferenceertmuserpeerid(
            StringConstant.rtmuserpeerid);

    if (value == null) return;
    _userpeerid = value;
    // debugPrint('userpeer Id:$userpeerid');
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString('action', widget.rtmpeerid);
    final allRows = await _dbHelper.queryRowCount(
        widget.rtmpeerid.toString(), _userpeerid.toString());
    chatLogController.clear();
    for (var row in allRows) {
      if (row != null) {
        ChatModel m = ChatModel(
          id: row['id'] == null ? '' : row['id'].toString() ?? '',
          message: row['message'],
          deliveryStatus: row['deliveryStatus'],
          diraction: row['diraction'],
          from: row['from_id'],
          reply: row['reply'],
          textId: row['textid'],
          timestamp: row['timestamp'],
          to: row['to_id'],
          type: row['type'],
          group: '',
          url: row['url'] ?? '',
          replyText: row['reply_text'],
        );
        chatLogController.addLog(m);
      }
    }
    // final dbHelper = DatabaseHelper.instance;
    await _dbHelper.deletebadge(widget.rtmpeerid);
  }

  @override
  void dispose() async {
    chatLogController.value.clear();
    _replytex = '';
    super.dispose();

    await _dbHelper.deletebadge(widget.rtmpeerid);
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString('action', 'nochatscreen');
    clearprefnacedata();
  }

  @override
  Widget build(BuildContext context) {
    // final size = MediaQuery.of(context).size;
    return WillPopScope(
      child: GradientColorBgView(
        // height: size.height,
        // decoration: const BoxDecoration(
        //   image: DecorationImage(
        //       image: AssetImage('assets/images/back_ground.jpg'),
        //       fit: BoxFit.fill),
        // ),
        child: SafeArea(
          child: Scaffold(
            backgroundColor: Colors.transparent,
            appBar: PreferredSize(
                preferredSize: Size.fromHeight(11.h),
                // here the desired height
                child: Column(
                  children: [
                    Container(
                        padding: EdgeInsets.symmetric(
                            horizontal: 1.h, vertical: 1.h),
                        child: Row(
                          crossAxisAlignment: CrossAxisAlignment.center,
                          mainAxisAlignment: MainAxisAlignment.spaceBetween,
                          children: [
                            Row(
                              children: [
                                InkWell(
                                    customBorder: const CircleBorder(),
                                    onTap: () {
                                      _dbHelper.deletebadge(widget.rtmpeerid);
                                      Navigator.pushAndRemoveUntil(
                                          context,
                                          MaterialPageRoute(
                                              builder: (context) =>
                                                  const BottomNavbar(index: 2)),
                                          (Route<dynamic> route) => false);
                                    },
                                    child: CircleAvatar(
                                      backgroundColor: Colors.transparent,
                                      radius: 18,
                                      child: Icon(Icons.keyboard_backspace,
                                          size: 3.h, color: Colors.white),
                                    )),
                                SizedBox(
                                  width: 1.h,
                                ),
                                InkWell(
                                  child: Row(
                                    children: [
                                      Container(
                                        height: 7.h,
                                        width: 15.w,
                                        decoration: BoxDecoration(
                                          borderRadius:
                                              BorderRadius.circular(10),
                                          color: Colors.white,
                                        ),
                                        child: ClipRRect(
                                          borderRadius:
                                              BorderRadius.circular(10),
                                          child: widget.recentchatuserdetails
                                                      .profile_image ==
                                                  ''
                                              ? Image.asset(
                                                  'assets/images/profile_demo.png',
                                                  height: 7.h,
                                                  width: 15.w,
                                                  fit: BoxFit.contain,
                                                )
                                              : CachedNetworkImage(
                                                  fit: BoxFit.cover,
                                                  width: 25.w,
                                                  height: 10.h,
                                                  imageUrl: StringConstant
                                                          .IMAGE_URL +
                                                      widget
                                                          .recentchatuserdetails
                                                          .profile_image,
                                                  placeholder: (context, url) =>
                                                      Helper.onScreenProgress(),
                                                  errorWidget: (context, url,
                                                          error) =>
                                                      const Icon(Icons.person),
                                                ),
                                        ),
                                      ),
                                      SizedBox(width: 1.h),
                                      SizedBox(
                                        width: 40.w,
                                        child: Column(
                                          crossAxisAlignment:
                                              CrossAxisAlignment.start,
                                          children: [
                                            Text(
                                              widget.recentchatuserdetails.name,
                                              maxLines: 1,
                                              style: TextStyle(
                                                  fontSize: 16.sp,
                                                  color: Colors.white,
                                                  overflow:
                                                      TextOverflow.ellipsis,
                                                  fontWeight: FontWeight.bold),
                                            ),
                                            statusWidget(),
                                          ],
                                        ),
                                      )
                                    ],
                                  ),
                                  onTap: () {
                                    Navigator.push(
                                        context,
                                        MaterialPageRoute(
                                            builder: (context) =>
                                                SenderProfilePage(
                                                    senderdetails: widget
                                                        .recentchatuserdetails,
                                                    peerid: _userpeerid,
                                                    status: widget.status,
                                                    // logcontroller:
                                                    //     widget.logController,
                                                    senderpeerid: widget
                                                        .recentchatuserdetails
                                                        .peerId,
                                                    senderName: widget
                                                        .recentchatuserdetails
                                                        .name)));
                                  },
                                ),
                              ],
                            ),
                            Row(
                              children: [
                                InkWell(
                                  customBorder: const CircleBorder(),
                                  child: CircleAvatar(
                                    backgroundColor: Colors.white,
                                    radius: 2.2.h,
                                    child: Image.asset(
                                      'assets/icons/svg/camera.png',
                                      height: 3.h,
                                      width: 3.h,
                                      color: const Color(0xFF5c0e35),
                                    ),
                                  ),
                                  onTap: () {
                                    Navigator.of(context).push(
                                      MaterialPageRoute(
                                        builder: (context) => VideoCallScreen(
                                          // userName: _loginData.id.toString(),
                                          userCallId: widget
                                              .recentchatuserdetails.id
                                              .toString(),
                                          userAuthToken: _loginData.authToken,
                                          userCallName:
                                              widget.recentchatuserdetails.name,
                                          calleeFcmToken: widget
                                              .recentchatuserdetails.fcm_token,
                                          devicefcmtoken: _devicefcmtoken,
                                          userprofileimage: _loginData.image,
                                        ),
                                      ),
                                    );
                                  },
                                ),
                                const SizedBox(width: 10),
                                InkWell(
                                  customBorder: const CircleBorder(),
                                  child: CircleAvatar(
                                    backgroundColor: Colors.white,
                                    radius: 2.2.h,
                                    child: Image.asset(
                                      'assets/icons/svg/call.png',
                                      height: 3.h,
                                      width: 3.h,
                                      color: const Color(0xFF5c0e35),
                                    ),
                                  ),
                                  onTap: () {
                                    Navigator.of(context).push(
                                      MaterialPageRoute(
                                        builder: (context) => AudioCallScreen(
                                          // userName: _loginData.id.toString(),
                                          userCallId:
                                              widget.recentchatuserdetails.id,
                                          myAuthToken: _loginData.authToken,
                                          userCallName:
                                              widget.recentchatuserdetails.name,
                                          userprofileimage: _loginData.image,
                                          othersFcmToken: widget
                                              .recentchatuserdetails.fcm_token,
                                          devicefcmtoken: _devicefcmtoken,
                                        ),
                                      ),
                                    );
                                  },
                                )
                              ],
                            )
                          ],
                        )),
                  ],
                )),
            body: Container(
              height: MediaQuery.of(context).size.height,
              width: MediaQuery.of(context).size.width,
              decoration: const BoxDecoration(
                borderRadius: BorderRadius.only(
                  topLeft: Radius.circular(20),
                  topRight: Radius.circular(20),
                ),
                color: Colors.transparent,
                image: DecorationImage(
                    image: AssetImage('assets/images/grey_background.jpg'),
                    fit: BoxFit.fill),
              ),
              child: Column(
                children: <Widget>[
                  Expanded(
                      child: Padding(
                    padding:
                        EdgeInsets.symmetric(horizontal: 1.h, vertical: 1.h),
                    child: Column(
                      children: <Widget>[
                        ValueListenableBuilder(
                          valueListenable: chatLogController,
                          builder: (context, log, wdgt) {
                            if (log.length > _length) {
                              _scrollDown(log.length);
                              if (_length == 0) {
                                _length = log.length;
                              } else if (_length != log.length) {
                                _length++;
                              }
                            }
                            return Expanded(
                              child: ListView.separated(
                                controller: _controller,
                                // physics: const NeverScrollableScrollPhysics(),
                                reverse: false,
                                shrinkWrap: true,
                                itemBuilder: (context, i) {
                                  ChatModel chatModel = log[i];
                                  // dynamic parts = log[i].split('#@####@#');
                                  print('print233' +
                                      chatModel.toJson().toString());

                                  if (chatModel.to == widget.rtmpeerid ||
                                      chatModel.from == widget.rtmpeerid) {
                                    // debugPrint('print message:' +
                                    //     chatModel.message +
                                    //     ' ' +
                                    //     chatModel.type);

                                    // if (parts.length > 0)

                                    if (chatModel.diraction.trim() != null &&
                                        chatModel.type != 'image' &&
                                        chatModel.type != 'network') {
                                      return SwipeTo(
                                          child: Container(
                                              alignment:
                                                  (chatModel.diraction != 'send'
                                                      ? Alignment.topLeft
                                                      : Alignment.topRight),
                                              child: Row(
                                                crossAxisAlignment:
                                                    CrossAxisAlignment.start,
                                                mainAxisAlignment: chatModel
                                                            .diraction !=
                                                        'send'
                                                    ? MainAxisAlignment.start
                                                    : MainAxisAlignment.end,
                                                children: [
                                                  if (chatModel.diraction ==
                                                      'Receive')
                                                    CircleAvatar(
                                                      backgroundColor:
                                                          const Color(
                                                              0xFF5c0e35),
                                                      child: Text(
                                                        widget
                                                            .recentchatuserdetails
                                                            .name[0],
                                                        style: const TextStyle(
                                                            color:
                                                                Colors.white),
                                                      ),
                                                    ),
                                                  const SizedBox(width: 10),
                                                  Container(
                                                    // constraints:
                                                    //     BoxConstraints(
                                                    //         minWidth: 30.w,
                                                    //         maxWidth: 60.w),
                                                    padding:
                                                        const EdgeInsets.all(0),
                                                    decoration: chatModel
                                                                .diraction !=
                                                            'send'
                                                        ? const BoxDecoration(
                                                            color:
                                                                Colors.black12,
                                                            borderRadius:
                                                                BorderRadius
                                                                    .only(
                                                              topRight: Radius
                                                                  .circular(10),
                                                              bottomLeft: Radius
                                                                  .circular(10),
                                                              bottomRight:
                                                                  Radius
                                                                      .circular(
                                                                          10),
                                                            ))
                                                        : const BoxDecoration(
                                                            gradient:
                                                                LinearGradient(
                                                              begin: Alignment
                                                                  .topCenter,
                                                              end: Alignment
                                                                  .bottomCenter,
                                                              colors: [
                                                                Color(
                                                                    0xFF901133),
                                                                Color(
                                                                    0xFF5c0e35),
                                                              ],
                                                            ),
                                                            borderRadius:
                                                                BorderRadius
                                                                    .only(
                                                              topLeft: Radius
                                                                  .circular(10),
                                                              //topRight: Radius.circular(10),
                                                              bottomLeft: Radius
                                                                  .circular(10),
                                                              bottomRight:
                                                                  Radius
                                                                      .circular(
                                                                          10),
                                                            ),
                                                          ),
                                                    child: GestureDetector(
                                                      onLongPressUp: () {
                                                        _popupdialog(
                                                            chatModel.id,
                                                            chatModel,
                                                            i);
                                                      },
                                                      onTap: () {
                                                        if (chatModel.type ==
                                                            'doc') {
                                                          Navigator.of(context)
                                                              .push(
                                                            MaterialPageRoute(
                                                              builder: (context) =>
                                                                  Pdfviewer(
                                                                      pdfpath:
                                                                          chatModel
                                                                              .url),
                                                            ),
                                                          );
                                                        } else if (chatModel
                                                                .type ==
                                                            'video') {
                                                          Navigator.of(context)
                                                              .push(
                                                            MaterialPageRoute(
                                                              builder: (context) =>
                                                                  Msgvideoplayer(
                                                                      videourl:
                                                                          chatModel
                                                                              .url),
                                                            ),
                                                          );
                                                        } else if (chatModel
                                                                .type ==
                                                            'image') {
                                                          Navigator.of(context)
                                                              .push(
                                                            MaterialPageRoute(
                                                              builder: (context) =>
                                                                  FullScreenImage(
                                                                      image: chatModel
                                                                          .url),
                                                            ),
                                                          );
                                                        }
                                                      },
                                                      child: Padding(
                                                          padding:
                                                              const EdgeInsets
                                                                  .all(5.0),
                                                          child: chatModel.type ==
                                                                      'text' ||
                                                                  chatModel
                                                                          .type ==
                                                                      'doc' ||
                                                                  chatModel
                                                                          .type ==
                                                                      'video'
                                                              ? Column(
                                                                  crossAxisAlignment:
                                                                      CrossAxisAlignment
                                                                          .end,
                                                                  // mainAxisSize:
                                                                  //     MainAxisSize
                                                                  //         .min,
                                                                  children: [
                                                                    Column(
                                                                      crossAxisAlignment:
                                                                          CrossAxisAlignment
                                                                              .start,
                                                                      children: [
                                                                        if (chatModel.reply ==
                                                                            'reply')
                                                                          _replyBox(
                                                                              chatModel.diraction,
                                                                              chatModel.replyText),
                                                                        if (chatModel.reply ==
                                                                            'forword')
                                                                          IntrinsicHeight(
                                                                            child:
                                                                                Text(chatModel.diraction == 'send' ? 'forward' : 'forwarded...', style: TextStyle(color: Colors.yellow, fontStyle: FontStyle.normal, fontWeight: FontWeight.w100)),
                                                                          ),
                                                                        if (chatModel.type ==
                                                                            'doc')
                                                                          const IntrinsicHeight(
                                                                            child:
                                                                                Text('Pdf', style: TextStyle(color: Colors.yellow, fontStyle: FontStyle.normal, fontWeight: FontWeight.w500)),
                                                                          ),
                                                                        if (chatModel.type ==
                                                                            'video')
                                                                          const IntrinsicHeight(
                                                                            child:
                                                                                Text('Video', style: TextStyle(color: Colors.yellow, fontStyle: FontStyle.normal, fontWeight: FontWeight.w500)),
                                                                          ),
                                                                        Container(
                                                                          constraints: BoxConstraints(
                                                                              minWidth: 25.w,
                                                                              maxWidth: 60.w),
                                                                          padding: const EdgeInsets.only(
                                                                              left: 8.0,
                                                                              right: 8.0,
                                                                              top: 5.0,
                                                                              bottom: 5),
                                                                          child: Row(
                                                                              mainAxisSize: MainAxisSize.min,
                                                                              mainAxisAlignment: MainAxisAlignment.spaceBetween,
                                                                              crossAxisAlignment: CrossAxisAlignment.center,
                                                                              children: [
                                                                                // if (chatModel.type == 'video' || chatModel.type == 'doc')
                                                                                //   _progressbar(log.length, log[i], i),
                                                                                textdocview(chatModel),
                                                                              ]),
                                                                        )
                                                                      ],
                                                                    ),
                                                                    Row(
                                                                      // mainAxisSize:
                                                                      //     MainAxisSize.min,
                                                                      mainAxisAlignment:
                                                                          MainAxisAlignment
                                                                              .end,
                                                                      crossAxisAlignment:
                                                                          CrossAxisAlignment
                                                                              .end,
                                                                      children: [
                                                                        // Flexible(),
                                                                        Text(
                                                                          DateFormat('hh:mm a')
                                                                              .format(DateTime.parse(chatModel.timestamp)),
                                                                          style: TextStyle(
                                                                              color: chatModel.diraction != 'send' ? Colors.black : Colors.white,
                                                                              fontSize: 10),
                                                                          textAlign:
                                                                              TextAlign.end,
                                                                        ),
                                                                        SizedBox(
                                                                            width:
                                                                                1.w),
                                                                        if (chatModel.diraction !=
                                                                            'Receive')
                                                                          doubletick(
                                                                              chatModel.deliveryStatus,
                                                                              chatModel.textId,
                                                                              log[i])
                                                                      ],
                                                                    )
                                                                  ],
                                                                )
                                                              : Column(
                                                                  children: [
                                                                    // if (chatModel.url?.isNotEmpty ==
                                                                    //         true &&
                                                                    //     chatModel
                                                                    //         .url
                                                                    //         .startsWith('http'))
                                                                    //   CachedNetworkImage(
                                                                    //     fit: BoxFit
                                                                    //         .cover,
                                                                    //     imageUrl:
                                                                    //         chatModel.url,
                                                                    //     placeholder: (context, url) =>
                                                                    //         LinearProgressIndicator(
                                                                    //       minHeight:
                                                                    //           20.sp,
                                                                    //     ),
                                                                    //     width:
                                                                    //         50.w,
                                                                    //     height:
                                                                    //         30.h,
                                                                    //     errorWidget: (context, url, error) =>
                                                                    //         const Icon(
                                                                    //       Icons.error,
                                                                    //       size:
                                                                    //           50,
                                                                    //     ),
                                                                    //   ),
                                                                    // if (chatModel.type ==
                                                                    //         'network' ||
                                                                    //     (chatModel.url?.isNotEmpty == true &&
                                                                    //         chatModel.url.startsWith('http')))
                                                                    //   CachedNetworkImage(
                                                                    //     fit: BoxFit
                                                                    //         .cover,
                                                                    //     imageUrl:
                                                                    //         chatModel.url,
                                                                    //     placeholder: (context, url) =>
                                                                    //         LinearProgressIndicator(
                                                                    //       minHeight:
                                                                    //           20.sp,
                                                                    //     ),
                                                                    //     width:
                                                                    //         50.w,
                                                                    //     height:
                                                                    //         30.h,
                                                                    //     errorWidget: (context, url, error) =>
                                                                    //         const Icon(
                                                                    //       Icons.error,
                                                                    //       size:
                                                                    //           50,
                                                                    //     ),
                                                                    //   ),
                                                                    chatModel.url?.isNotEmpty ==
                                                                                true &&
                                                                            ((chatModel.type == 'image' || chatModel.type == 'network') &&
                                                                                chatModel.url.startsWith('http'))
                                                                        ? CachedNetworkImage(
                                                                            fit:
                                                                                BoxFit.cover,
                                                                            imageUrl:
                                                                                chatModel.url,
                                                                            placeholder: (context, url) =>
                                                                                LinearProgressIndicator(
                                                                              minHeight: 20.sp,
                                                                            ),
                                                                            width:
                                                                                50.w,
                                                                            height:
                                                                                30.h,
                                                                            errorWidget: (context, url, error) =>
                                                                                const Icon(
                                                                              Icons.error,
                                                                              size: 50,
                                                                            ),
                                                                          )
                                                                        : (chatModel.url?.isNotEmpty == true && (chatModel.type == 'image' || chatModel.type == 'network'))
                                                                            ? Image.file(File(chatModel.url),
                                                                                fit: BoxFit.cover,
                                                                                errorBuilder: (context, url, error) => const Icon(
                                                                                      Icons.error,
                                                                                      size: 70,
                                                                                      color: Colors.red,
                                                                                      semanticLabel: 'image not found',
                                                                                    ))
                                                                            : Container(),
                                                                    const SizedBox(
                                                                        height:
                                                                            10),
                                                                    Row(
                                                                        mainAxisAlignment:
                                                                            MainAxisAlignment.end,
                                                                        children: [
                                                                          Text(
                                                                            DateFormat('hh:mm a').format(DateTime.parse(chatModel.timestamp)),
                                                                            style:
                                                                                TextStyle(color: chatModel.diraction != 'send' ? Colors.black : Colors.white, fontSize: 10),
                                                                            textAlign:
                                                                                TextAlign.right,
                                                                          ),
                                                                          SizedBox(
                                                                            width:
                                                                                1.w,
                                                                          ),
                                                                          if (chatModel.diraction !=
                                                                              'Receive')
                                                                            doubletick(
                                                                                chatModel.deliveryStatus,
                                                                                chatModel.textId,
                                                                                log[i])
                                                                        ]),
                                                                  ],
                                                                )),
                                                    ),
                                                  ),
                                                  const SizedBox(
                                                    width: 10,
                                                  ),
                                                  if (chatModel.diraction ==
                                                      'send')
                                                    CircleAvatar(
                                                      backgroundColor:
                                                          const Color(
                                                              0xFF901133),
                                                      child: Text(
                                                          '${_loginData.name[0]}',
                                                          style:
                                                              const TextStyle(
                                                                  color: Colors
                                                                      .white)),
                                                    ),
                                                ],
                                              )),
                                          onLeftSwipe: () {
                                            setState(() {
                                              _replyVisibility = true;
                                              _replytex = chatModel.message;
                                              // replytext(chatModel);
                                              if (chatModel.type != 'text' &&
                                                  chatModel.url?.isNotEmpty ==
                                                      true) {
                                                _replyImagePath = chatModel.url;
                                                _afile = fileExp
                                                    .hasMatch(_replyImagePath);
                                              }
                                              // debugPrint(afile);
                                            });
                                          });
                                    } else {
                                      return Container(
                                        padding: const EdgeInsets.only(
                                            right: 0.0,
                                            left: 0.0,
                                            top: 2,
                                            bottom: 2),
                                        alignment:
                                            (chatModel.diraction != 'send'
                                                ? Alignment.topLeft
                                                : Alignment.topRight),
                                        child: GestureDetector(
                                          onLongPressUp: () {
                                            _popupdialog(
                                                chatModel.id, chatModel, i);
                                          },
                                          onTap: () {
                                            Navigator.of(context).push(
                                                MaterialPageRoute(
                                                    builder: (context) =>
                                                        FullScreenImage(
                                                            image: chatModel
                                                                .url)));
                                          },
                                          child: Padding(
                                              padding:
                                                  const EdgeInsets.all(5.0),
                                              child: Row(
                                                crossAxisAlignment:
                                                    CrossAxisAlignment.start,
                                                mainAxisAlignment: chatModel
                                                            .diraction !=
                                                        'send'
                                                    ? MainAxisAlignment.start
                                                    : MainAxisAlignment.end,
                                                children: [
                                                  if (chatModel.diraction ==
                                                      'Receive')
                                                    CircleAvatar(
                                                      backgroundColor:
                                                          const Color(
                                                              0xFF5c0e35),
                                                      child: Text(
                                                        '${widget.recentchatuserdetails.name[0]}',
                                                        style: const TextStyle(
                                                            color:
                                                                Colors.white),
                                                      ),
                                                    ),
                                                  const SizedBox(
                                                    width: 10,
                                                  ),
                                                  Expanded(
                                                      child:
                                                          chatModel.type ==
                                                                  'text'
                                                              ? Column(
                                                                  crossAxisAlignment:
                                                                      CrossAxisAlignment
                                                                          .start,
                                                                  children: <
                                                                      Widget>[
                                                                    chatModel.reply ==
                                                                            'reply'
                                                                        ? Container(
                                                                            decoration:
                                                                                BoxDecoration(color: Colors.grey, borderRadius: BorderRadius.circular(8.0)),
                                                                            child:
                                                                                Column(
                                                                              children: [
                                                                                IntrinsicHeight(
                                                                                  child: Row(
                                                                                    children: [
                                                                                      Container(
                                                                                        decoration: const BoxDecoration(
                                                                                          color: Colors.red,
                                                                                          borderRadius: BorderRadius.only(
                                                                                            bottomLeft: Radius.circular(30.0),
                                                                                            topLeft: Radius.circular(30.0),
                                                                                          ),
                                                                                        ),
                                                                                        width: 5.0,
                                                                                      ),
                                                                                      Expanded(
                                                                                        child: Padding(
                                                                                          padding: const EdgeInsets.all(7.0),
                                                                                          child: Container(
                                                                                            decoration: BoxDecoration(
                                                                                              // color: Colors.grey,
                                                                                              borderRadius: BorderRadius.circular(8.0),
                                                                                            ),
                                                                                            child: Column(
                                                                                              crossAxisAlignment: CrossAxisAlignment.start,
                                                                                              children: [
                                                                                                const Text(
                                                                                                  'Reply',
                                                                                                  style: TextStyle(
                                                                                                    fontSize: 18.0,
                                                                                                    color: Colors.red,
                                                                                                  ),
                                                                                                ),
                                                                                                Text(
                                                                                                  'Replied message' + _replytex,
                                                                                                  style: const TextStyle(
                                                                                                    fontSize: 14.0,
                                                                                                    color: Colors.black,
                                                                                                  ),
                                                                                                )
                                                                                              ],
                                                                                            ),
                                                                                          ),
                                                                                        ),
                                                                                      )
                                                                                    ],
                                                                                  ),
                                                                                ),
                                                                              ],
                                                                            ),
                                                                          )
                                                                        : Container(),
                                                                    Text(
                                                                      chatModel
                                                                          .message
                                                                          .trim(),
                                                                      style: TextStyle(
                                                                          color: chatModel.diraction != 'send'
                                                                              ? Colors.black
                                                                              : Colors.white,
                                                                          fontSize: 16),
                                                                      textAlign:
                                                                          TextAlign
                                                                              .left,
                                                                    )
                                                                  ],
                                                                )
                                                              : Container(
                                                                  constraints: BoxConstraints(
                                                                      minWidth:
                                                                          30.w,
                                                                      maxWidth:
                                                                          60.w),
                                                                  alignment: (chatModel
                                                                              .diraction !=
                                                                          'send'
                                                                      ? Alignment
                                                                          .topLeft
                                                                      : Alignment
                                                                          .topRight),
                                                                  child: Stack(
                                                                    children: [
                                                                      chatModel.type == 'image' ||
                                                                              chatModel.type == 'network'
                                                                          ? Stack(
                                                                              alignment: Alignment.center,
                                                                              children: [
                                                                                ConstrainedBox(
                                                                                  constraints: const BoxConstraints(maxHeight: 300, minHeight: 200, maxWidth: 500, minWidth: 200),
                                                                                  child: ClipRRect(
                                                                                    borderRadius: const BorderRadius.only(
                                                                                      topLeft: Radius.circular(10),
                                                                                      //topRight: Radius.circular(10),
                                                                                      bottomLeft: Radius.circular(10),
                                                                                      bottomRight: Radius.circular(10),
                                                                                    ),
                                                                                    child: (chatModel.url?.isNotEmpty == true && chatModel.url.startsWith('http'))
                                                                                        ? CachedNetworkImage(
                                                                                            fit: BoxFit.cover,
                                                                                            imageUrl: chatModel.url,
                                                                                            placeholder: (context, url) => LinearProgressIndicator(
                                                                                              minHeight: 20.sp,
                                                                                            ),
                                                                                            width: 50.w,
                                                                                            height: 30.h,
                                                                                            errorWidget: (context, url, error) => const Icon(
                                                                                              Icons.error,
                                                                                              size: 50,
                                                                                            ),
                                                                                          )
                                                                                        : Image.file(File(chatModel.url),
                                                                                            fit: BoxFit.cover,
                                                                                            errorBuilder: (context, url, error) => const Icon(
                                                                                                  Icons.error,
                                                                                                  size: 70,
                                                                                                  color: Colors.blue,
                                                                                                  semanticLabel: 'image not found',
                                                                                                )),
                                                                                  ),
                                                                                ),
                                                                                // imageprogressbar(log.length, log[i], i),
                                                                              ],
                                                                            )
                                                                          : chatModel.type == 'video'
                                                                              ? ClipRRect(
                                                                                  borderRadius: const BorderRadius.only(topLeft: Radius.circular(10), bottomLeft: Radius.circular(10), bottomRight: Radius.circular(10)),
                                                                                  child: AspectRatio(
                                                                                    aspectRatio: 9 / 16,
                                                                                    child: VideoPlayer(VideoPlayerController.network(chatModel.url)),
                                                                                  ))
                                                                              : CachedNetworkImage(
                                                                                  fit: BoxFit.cover,
                                                                                  imageUrl: chatModel.url,
                                                                                  /*height: 40.h,
                                                                                      width: 60.w,*/
                                                                                  placeholder: (context, url) => LinearProgressIndicator(
                                                                                    minHeight: 20.sp,
                                                                                  ),
                                                                                  errorWidget: (context, url, error) => const Icon(
                                                                                    Icons.error,
                                                                                    size: 50,
                                                                                  ),
                                                                                ),
                                                                      Positioned(
                                                                        bottom:
                                                                            2,
                                                                        right:
                                                                            4,
                                                                        child:
                                                                            Align(
                                                                          alignment:
                                                                              Alignment.bottomRight,
                                                                          child:
                                                                              Row(
                                                                            mainAxisAlignment:
                                                                                MainAxisAlignment.end,
                                                                            crossAxisAlignment:
                                                                                CrossAxisAlignment.end,
                                                                            children: [
                                                                              Text(
                                                                                DateFormat('hh:mm a').format(DateTime.parse(chatModel.timestamp)),
                                                                                style: TextStyle(color: chatModel.diraction != 'send' ? Colors.black : Colors.white, fontSize: 10),
                                                                                textAlign: TextAlign.end,
                                                                              ),
                                                                              SizedBox(
                                                                                width: 1.w,
                                                                              ),
                                                                              if (chatModel.diraction != 'Receive')
                                                                                doubletick(chatModel.deliveryStatus, chatModel.textId, log[i])

                                                                              /*: Icon(
                                                                                          Icons.done_all_outlined,
                                                                                          color: onlinestatus == 'online' ? Colors.blue : Colors.white,
                                                                                          size: 15,
                                                                                        ),*/
                                                                            ],
                                                                          ),
                                                                        ),
                                                                      )
                                                                    ],
                                                                  ),
                                                                )),
                                                  const SizedBox(
                                                    width: 10,
                                                  ),
                                                  if (chatModel.diraction ==
                                                      'send')
                                                    CircleAvatar(
                                                      backgroundColor:
                                                          const Color(
                                                              0xFF901133),
                                                      child: Text(
                                                          '${_loginData.name[0]}',
                                                          style: TextStyle(
                                                              color: Colors
                                                                  .white)),
                                                    ),
                                                ],
                                              )),
                                        ),
                                      );
                                    }

                                    //  else {
                                    //   return null;
                                    // }
                                  } else {
                                    return null;
                                  }
                                },
                                itemCount: log.length,
                                separatorBuilder:
                                    (BuildContext context, int index) =>
                                        SizedBox(height: 2.h),
                              ),
                            );
                          },
                        )
                      ],
                    ),
                  )),
                  //SizedBox(height: 10,),
                  Align(
                      alignment: Alignment.bottomCenter,
                      child: Container(
                        decoration: const BoxDecoration(
                            //borderRadius: BorderRadius.circular(30),
                            gradient: LinearGradient(
                          //begin: Alignment.center,
                          // end: Alignment.center,
                          stops: [0.0, 0.8],
                          tileMode: TileMode.clamp,
                          begin: Alignment.topCenter,
                          end: Alignment.bottomCenter,
                          colors: [
                            Color(0xFF901133),
                            Color(0xFF5c0e35),
                          ],
                        )),
                        padding: const EdgeInsets.symmetric(
                            vertical: 5, horizontal: 5),
                        child: Row(
                          mainAxisAlignment: MainAxisAlignment.spaceBetween,
                          crossAxisAlignment: CrossAxisAlignment.center,
                          children: <Widget>[
                            Expanded(
                                child: Container(
                              padding: const EdgeInsets.symmetric(
                                horizontal: 0,
                                vertical: 0,
                              ),
                              decoration: BoxDecoration(
                                color: Colors.white,
                                borderRadius: _replyVisibility == true
                                    ? const BorderRadius.only(
                                        topLeft: Radius.circular(10),
                                        topRight: Radius.circular(10),
                                        bottomLeft: Radius.circular(10),
                                        bottomRight: Radius.circular(10),
                                      )
                                    : BorderRadius.circular(10.0),
                              ),
                              child: Column(
                                children: <Widget>[
                                  Visibility(
                                    visible: _replyVisibility,
                                    child: Container(
                                      margin: const EdgeInsets.only(
                                          left: 8.0, right: 8.0, top: 8.0),
                                      decoration: BoxDecoration(
                                        color: ColorConstant.replaybluegray,
                                        borderRadius:
                                            BorderRadius.circular(8.0),
                                      ),
                                      child: Column(
                                        children: [
                                          IntrinsicHeight(
                                            child: Row(
                                              children: [
                                                Container(
                                                  decoration:
                                                      const BoxDecoration(
                                                    color: Colors.red,
                                                    borderRadius:
                                                        BorderRadius.only(
                                                      bottomLeft:
                                                          Radius.circular(30.0),
                                                      topLeft:
                                                          Radius.circular(30.0),
                                                    ),
                                                  ),
                                                  width: 5.0,
                                                ),
                                                Expanded(
                                                  child: Padding(
                                                    padding:
                                                        const EdgeInsets.all(
                                                            7.0),
                                                    child: Container(
                                                      decoration: BoxDecoration(
                                                        // color: Colors.grey,
                                                        borderRadius:
                                                            BorderRadius
                                                                .circular(8.0),
                                                      ),
                                                      child: Column(
                                                        crossAxisAlignment:
                                                            CrossAxisAlignment
                                                                .start,
                                                        children: [
                                                          Row(
                                                            mainAxisAlignment:
                                                                MainAxisAlignment
                                                                    .spaceBetween,
                                                            children: <Widget>[
                                                              Text(
                                                                'Reply',
                                                                style:
                                                                    TextStyle(
                                                                  fontSize:
                                                                      13.sp,
                                                                  fontWeight:
                                                                      FontWeight
                                                                          .bold,
                                                                  color: Colors
                                                                      .red,
                                                                ),
                                                              ),
                                                              IconButton(
                                                                padding:
                                                                    EdgeInsets
                                                                        .zero,
                                                                onPressed: () {
                                                                  setState(() {
                                                                    _replyVisibility =
                                                                        false;
                                                                    _replytex =
                                                                        '';
                                                                  });
                                                                },
                                                                icon:
                                                                    const Icon(
                                                                  Icons.close,
                                                                  size: 20,
                                                                ),
                                                              ),
                                                            ],
                                                          ),
                                                          images(),
                                                        ],
                                                      ),
                                                    ),
                                                  ),
                                                )
                                              ],
                                            ),
                                          ),
                                        ],
                                      ),
                                    ),
                                  ),
                                  ConstrainedBox(
                                    constraints: BoxConstraints(
                                      maxHeight: 10.h,
                                    ),
                                    child: TextField(
                                      controller: _peerMessage,
                                      autofocus: false,
                                      minLines: 1,
                                      maxLines: 5,
                                      keyboardType: TextInputType.multiline,
                                      decoration: InputDecoration(
                                        hintText: 'Type your message',
                                        border: InputBorder.none,
                                        hintStyle: TextStyle(
                                            fontSize: 2.h,
                                            color: Colors.black38),
                                        focusedBorder: InputBorder.none,
                                        enabledBorder: InputBorder.none,
                                        errorBorder: InputBorder.none,
                                        disabledBorder: InputBorder.none,
                                        contentPadding: const EdgeInsets.only(
                                            left: 10, bottom: 0),
                                      ),
                                      onChanged: (value) {
                                        if (_isInputBoxEmpty == value.isEmpty) {
                                          return;
                                        }
                                        setState(() {
                                          _isInputBoxEmpty = value.isEmpty;
                                        });
                                        // if (_isInputBoxEmpty !=
                                        //         value?.isEmpty ??
                                        //     true) {
                                        //   setState(() {
                                        //     _isInputBoxEmpty = value.isEmpty;
                                        //   });
                                        // }
                                        // if (value.isNotEmpty) {
                                        //   setState(() {
                                        //     _enteredText = _peerMessage.text;
                                        //   });
                                        // }
                                      },
                                    ),
                                  ),
                                ],
                              ),
                            )),
                            const SizedBox(
                              width: 10,
                            ),
                            _isInputBoxEmpty && !_sendingMessage
                                ? SizedBox(
                                    width: 8.h,
                                    child: Row(
                                      mainAxisAlignment:
                                          MainAxisAlignment.spaceBetween,
                                      crossAxisAlignment:
                                          CrossAxisAlignment.center,
                                      children: [
                                        InkWell(
                                          onTap: () {
                                            addAttachment();
                                            // debugPrint('mic button pressed');
                                          },
                                          child: Icon(
                                            Icons.attachment,
                                            size: 3.h,
                                            color: Colors.white,
                                          ),
                                        ),
                                        InkWell(
                                          onTap: () {
                                            // debugPrint('add button pressed');
                                            getImage(ImageSource.camera);
                                          },
                                          child: Icon(Icons.photo_camera,
                                              size: 3.h, color: Colors.white),
                                        ),
                                      ],
                                    ),
                                  )
                                : Container(),
                            const SizedBox(width: 5),
                            !_isInputBoxEmpty || _sendingMessage
                                ? Align(
                                    alignment: Alignment.bottomRight,
                                    child: CircleAvatar(
                                      backgroundColor: Colors.white,
                                      radius: 22,
                                      child: IconButton(
                                          icon: Icon(
                                            _sendingMessage
                                                ? Icons.access_time
                                                : Icons.send,
                                            color: const Color(0xFF5c0e35),
                                            size: 25,
                                          ),
                                          onPressed: _sendingMessage
                                              ? null
                                              : () {
                                                  if (_peerMessage.text
                                                      .trim()
                                                      .isEmpty) {
                                                    //EasyLoading.showToast('Kya yrr kuch toh likho');
                                                  } else {
                                                    setState(() {
                                                      _isInputBoxEmpty = true;
                                                    });
                                                    _sendPeerMessage();
                                                  }
                                                }),
                                    ),
                                  )
                                // : _sendingMessage
                                //     ? const Center(
                                //         child: CircularProgressIndicator(),
                                //       )
                                : Container()
                          ],
                        ),
                      )),
                ],
              ),
            ),
          ),
        ),
      ),
      onWillPop: () async {
        _dbHelper.deletebadge(widget.rtmpeerid);
        return Navigator.pushAndRemoveUntil(
            context,
            MaterialPageRoute(
              builder: (context) => const BottomNavbar(
                index: 2,
              ),
            ),
            (Route<dynamic> route) => false);
      },
    );
  }

  addAttachment() {
    showModalBottomSheet(
      context: context,
      backgroundColor: Colors.transparent,
      builder: (BuildContext context) {
        return StatefulBuilder(
            builder: (BuildContext context, StateSetter setState) {
          return Container(
            height: 25.h,
            // margin: EdgeInsets.symmetric(horizontal: 10, vertical: 10),
            padding: const EdgeInsets.all(10),
            decoration: BoxDecoration(
                borderRadius: BorderRadius.circular(20), color: Colors.white),
            child: Column(
              children: [
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    Text(
                      'Choose One',
                      style: TextStyle(fontSize: 15.sp),
                    ),
                    IconButton(
                        onPressed: () {
                          Navigator.pop(context);
                        },
                        icon: const Icon(Icons.cancel))
                  ],
                ),
                Padding(
                    padding:
                        EdgeInsets.symmetric(horizontal: 1.h, vertical: 1.h),
                    child: Column(
                      children: [
                        Row(
                          mainAxisAlignment: MainAxisAlignment.spaceAround,
                          children: [
                            Column(
                              children: [
                                CircleAvatar(
                                  radius: 25,
                                  backgroundColor:
                                      AppColors.appNewDarkThemeColor,
                                  child: IconButton(
                                    icon: const Icon(
                                      Icons.camera_alt,
                                      color: Colors.white,
                                    ),
                                    onPressed: () {
                                      setState(() {
                                        getImage(ImageSource.camera);
                                        Navigator.pop(context);
                                      });
                                    },
                                  ),
                                ),
                                const Text('Camera')
                              ],
                            ),
                            Column(
                              children: [
                                CircleAvatar(
                                  radius: 25,
                                  backgroundColor:
                                      AppColors.appNewDarkThemeColor,
                                  child: IconButton(
                                    icon: const Icon(
                                      Icons.image,
                                      color: Colors.white,
                                    ),
                                    onPressed: () {
                                      setState(() {
                                        getImage(ImageSource.gallery);
                                        Navigator.pop(context);
                                      });
                                    },
                                  ),
                                ),
                                const Text('Gallery')
                              ],
                            ),
                            Column(
                              children: [
                                CircleAvatar(
                                  radius: 25,
                                  backgroundColor:
                                      AppColors.appNewDarkThemeColor,
                                  child: IconButton(
                                    icon: const Icon(
                                      Icons.videocam,
                                      color: Colors.white,
                                    ),
                                    onPressed: () {
                                      setState(() {
                                        _pickVideoFromGallery();
                                        Navigator.pop(context);
                                      });
                                    },
                                  ),
                                ),
                                const Text('Video')
                              ],
                            ),
                            Column(
                              children: [
                                CircleAvatar(
                                  radius: 25,
                                  backgroundColor:
                                      AppColors.appNewDarkThemeColor,
                                  child: IconButton(
                                    icon: const Icon(
                                      Icons.video_collection,
                                      color: Colors.white,
                                    ),
                                    onPressed: () {
                                      setState(() {
                                        _pickpdf();
                                        Navigator.pop(context);
                                      });
                                    },
                                  ),
                                ),
                                const Text('Pdf')
                              ],
                            ),
                          ],
                        ),
                      ],
                    ))
              ],
            ),
          );
        });
      },
    );
  }

  Future<void> getImage(ImageSource source) async {
    final pickedFile =
        await _picker.pickImage(source: source, imageQuality: 50);
    var textid = DateTime.now().millisecondsSinceEpoch.toString();

    ChatModel model = ChatModel(
        from: _userpeerid,
        to: widget.rtmpeerid,
        message: _peerMessage.text,
        reply: 'noreplay',
        replyText: '',
        diraction: 'send',
        timestamp: DateTime.now().toString(),
        type: 'image',
        deliveryStatus: 'new',
        textId: textid);

    if (_replytex != '') {
      model.replyText = _replytex;
      model.reply = 'reply';
    }
    imageapi(pickedFile, widget.rtmpeerid, model);
    // widget.logController.addLog(model);
    // if (replytex != '') {
    //   var file = replytex +
    //       '#@####@#replay#@####@#' +
    //       pickedFile.path +
    //       '#@####@#send' +
    //       '#@####@#image' +
    //       '#@####@#' +
    //       DateTime.now().toString() +
    //       '#@####@#' +
    //       '' +
    //       '#@####@#' +
    //       widget.rtmpeerid +
    //       '#@####@#' +
    //       'new';
    //   widget.logController.addLog(file);
    //   // _insert(replytex + '#@####@#replay#@####@#' + pickedFile.path, 'image', 'send', widget.rtmpeerid.toString());
    // } else {
    //   var file = replytex +
    //       '#@####@#noreplay#@####@#' +
    //       pickedFile.path +
    //       '#@####@#send' +
    //       '#@####@#image' +
    //       '#@####@#' +
    //       DateTime.now().toString() +
    //       '#@####@#' +
    //       '' +
    //       '#@####@#' +
    //       widget.rtmpeerid +
    //       '#@####@#' +
    //       'new';
    //   widget.logController.addLog(file);
    //   //_insert(replytex + '#@####@#noreplay#@####@#' + pickedFile.path, 'image', 'send', widget.rtmpeerid.toString());
    // }
  }

  _replyBox(String diraction, String replyText) {
    return IntrinsicHeight(
      child: Container(
        // width: 12.h,

        margin: const EdgeInsets.only(left: 8.0, right: 8.0, top: 8.0),
        decoration: BoxDecoration(
            color: Colors.white, borderRadius: BorderRadius.circular(8.0)),
        child: IntrinsicHeight(
          child: Container(
            constraints: BoxConstraints(minWidth: 10.w, maxWidth: 40.w),
            decoration: BoxDecoration(
              color: const Color(0xFFf8ece8),
              borderRadius: BorderRadius.circular(8.0),
            ),
            child: Row(
              mainAxisSize: MainAxisSize.min,
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              crossAxisAlignment: CrossAxisAlignment.center,
              children: [
                Container(
                  decoration: BoxDecoration(
                    color: diraction != 'send'
                        ? const Color(0xFF800000)
                        : Colors.white,
                    borderRadius: const BorderRadius.only(
                      bottomLeft: Radius.circular(30.0),
                      topLeft: Radius.circular(30.0),
                    ),
                  ),
                  width: 5.0,
                ),
                const SizedBox(
                  height: 5,
                ),
                Expanded(
                  child: Container(
                      padding: const EdgeInsets.symmetric(
                          vertical: 8, horizontal: 8),
                      decoration: const BoxDecoration(
                        color: Color(0xFFf8ece8),
                        borderRadius: BorderRadius.only(
                          bottomRight: Radius.circular(30.0),
                          topRight: Radius.circular(30.0),
                        ),
                      ),
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          diraction != 'send'
                              ? const Text(
                                  'You',
                                  style: TextStyle(
                                    fontSize: 14.0,
                                    fontWeight: FontWeight.w600,
                                    color: Colors.black,
                                  ),
                                )
                              : Text(
                                  _recieptPerson,
                                  style: const TextStyle(
                                    fontSize: 14.0,
                                    fontWeight: FontWeight.w600,
                                    color: Colors.black,
                                  ),
                                ),
                          Text(
                            replyText ?? '',
                            // parts[0],
                            style: TextStyle(
                              fontSize: 14.0,
                              color: AppColors.cardContainerColor,
                            ),
                          )
                        ],
                      )),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  _pickpdf() async {
    FilePickerResult result = await FilePicker.platform.pickFiles(
      type: FileType.custom,
      allowedExtensions: ['pdf', 'doc'],
    );
    PlatformFile files = result.files.first;
    var textid = DateTime.now().millisecondsSinceEpoch.toString();
    ChatModel model = ChatModel(
        from: _userpeerid,
        to: widget.rtmpeerid,
        message: _peerMessage.text,
        reply: 'noreplay',
        replyText: '',
        diraction: 'send',
        timestamp: DateTime.now().toString(),
        type: 'doc',
        deliveryStatus: 'new',
        textId: textid);

    if (_replytex != '') {
      model.replyText = _replytex;
      model.reply = 'reply';
    }

    final file = XFile(files.path);
    imageapi(file, widget.rtmpeerid, model);
    // await _insert(model);
    // widget.logController.addLog(model);
    // if (replytex != '') {
    //   var file = replytex +
    //       '#@####@#replay#@####@#' +
    //       files.path +
    //       '#@#&' +
    //       files.name +
    //       '#@####@#send' +
    //       '#@####@#doc' +
    //       '#@####@#' +
    //       DateTime.now().toString() +
    //       '#@####@#' +
    //       '' +
    //       '#@####@#' +
    //       widget.rtmpeerid +
    //       '#@####@#' +
    //       'new';
    //   widget.logController.addLog(file);

    //   _insert(
    //       replytex +
    //           '#@####@#replay#@####@#' +
    //           files.path +
    //           '#@#&' +
    //           files.name,
    //       'doc',
    //       'send',
    //       widget.rtmpeerid.toString());
    // } else {
    //   var file = replytex +
    //       '#@####@#noreplay#@####@#' +
    //       files.path +
    //       '#@#&' +
    //       files.name +
    //       '#@####@#send' +
    //       '#@####@#doc' +
    //       '#@####@#' +
    //       DateTime.now().toString() +
    //       '#@####@#' +
    //       '' +
    //       '#@####@#' +
    //       widget.rtmpeerid +
    //       '#@####@#' +
    //       'new';
    //   widget.logController.addLog(file);
    //   _insert(
    //       replytex +
    //           '#@####@#noreplay#@####@#' +
    //           files.path +
    //           '#@#&' +
    //           files.name,
    //       'doc',
    //       'send',
    //       widget.rtmpeerid.toString());
    // }
    updatelocaldata(widget.rtmpeerid);
  }

  _pickVideoFromGallery() async {
    FilePickerResult result = await FilePicker.platform
        .pickFiles(type: FileType.custom, allowedExtensions: ['mp4']);
    PlatformFile files = result.files.first;
    final file = XFile(files.path);
    var textid = DateTime.now().millisecondsSinceEpoch.toString();
    ChatModel model = ChatModel(
        from: _userpeerid,
        to: widget.rtmpeerid,
        message: _peerMessage.text,
        reply: 'noreplay',
        replyText: '',
        diraction: 'send',
        timestamp: DateTime.now().toString(),
        type: 'video',
        deliveryStatus: 'new',
        textId: textid);

    if (_replytex != '') {
      model.replyText = _replytex;
      model.reply = 'reply';
    }
    videoAPI(file, model);
  }

  void _scrollDown(log) {
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _controller.jumpTo(_controller.position.maxScrollExtent + 10);
    });
  }

  void _sendPeerMessage() async {
    debugPrint('out_message' + _peerMessage.text);
    if (widget.rtmpeerid.isEmpty) {
      // widget.logController.addLog('Please input peer user id to send message.');
      return;
    }
    if (_peerMessage.text.isEmpty) {
      // widget.logController.addLog('Please input text to send.');
      return;
    }
    if (widget.status != 'active') {
      EasyLoading.showToast('unblock a user first',
          toastPosition: EasyLoadingToastPosition.center,
          duration: const Duration(seconds: 5));
      return;
    }
    if (widget.recentchatuserdetails.transit_allowed == 'No') {
      EasyLoading.showToast(widget.recentchatuserdetails.name + ' Blocked you',
          toastPosition: EasyLoadingToastPosition.center,
          duration: const Duration(seconds: 5));
      return;
    }
    setState(() {
      _sendingMessage = true;
    });
    // await Future.delayed(const Duration(seconds: 5));

    updatelocaldata(widget.rtmpeerid);
    var textid = DateTime.now().millisecondsSinceEpoch.toString();
    ChatModel model = ChatModel(
        from: _userpeerid,
        to: widget.rtmpeerid,
        message: _peerMessage.text,
        reply: 'noreplay',
        replyText: '',
        diraction: 'send',
        timestamp: DateTime.now().toString(),
        type: 'text',
        deliveryStatus: 'new',
        textId: textid);

    try {
      if (_replytex != '') {
        model.reply = 'reply';
        model.replyText = _replytex;
      }
      // model.timestamp = DateTime.now().toString();
      AgoraRtmMessage message =
          AgoraRtmMessage.fromText(jsonEncode(model.toJson()));
      // debugPrint('messagereplay' + _peerMessage.text);
      await _client.sendMessageToPeer(widget.rtmpeerid, message, true, false);

      final id = await _insert(model);
      model.id = id.toString();
      chatLogController.addLog(model);

      await _sendFCMPushChat(model);

      updatelocaldata(widget.rtmpeerid);
      _peerMessage.clear();
      setState(() {
        _replyVisibility = false;
        _replytex = '';
        _sendingMessage = false;
      });
    } catch (errorCode) {
      debugPrint('error :$errorCode');
      EasyLoading.showToast('error code:-' + errorCode.toString(),
          toastPosition: EasyLoadingToastPosition.bottom,
          duration: const Duration(seconds: 5));

      setState(() {
        _sendingMessage = false;
      });
    }
  }

  sendMessage(AgoraRtmMessage message) async {
    await widget.client
        .sendMessageToPeer(widget.rtmpeerid, message, true, false);
  }

  /// Inserting  chat data in local database.
  // _insert(String _peerMessage, String type, diraction, rtmpeerid) async {
  //   // row to insert
  //   Map<String, dynamic> row = {
  //     DatabaseHelper.Id: null,
  //     DatabaseHelper.message: _peerMessage,
  //     DatabaseHelper.timestamp: DateTime.now().toString(),
  //     DatabaseHelper.diraction: diraction,
  //     DatabaseHelper.reply: replytex,
  //     DatabaseHelper.type: type,
  //     DatabaseHelper.from: rtmpeerid,
  //     DatabaseHelper.to: userpeerid.toString(),
  //     DatabaseHelper.deliveryStatus: 'Undelivered',
  //     DatabaseHelper.textId: DateTime.now().toString(),
  //   };
  //   final id = await dbHelper.insert(row);
  //   debugPrint('inserted row id: $id');
  //   return id;
  // }

  /// Inserting  chat data in local database.
  Future<int> _insert(ChatModel model) async {
    // row to insert
    Map<String, dynamic> row = {
      DatabaseHelper.Id: null,
      DatabaseHelper.message: model.message,
      DatabaseHelper.timestamp: DateTime.now().toString(),
      DatabaseHelper.diraction: 'send',
      DatabaseHelper.reply: model.reply,
      DatabaseHelper.replyText: model.replyText,
      DatabaseHelper.type: model.type,
      DatabaseHelper.from: _userpeerid,
      DatabaseHelper.to: widget.rtmpeerid,
      DatabaseHelper.deliveryStatus: 'Undelivered',
      DatabaseHelper.textId: model.textId,
      DatabaseHelper.url: model.url ?? ''
    };
    final id = await _dbHelper.insert(row);
    debugPrint('inserted row id: $id');
    return id;
  }

  Future<int> _insertForward(ChatModel model, String toId) async {
    // row to insert
    Map<String, dynamic> row = {
      DatabaseHelper.Id: null,
      DatabaseHelper.message: model.message,
      DatabaseHelper.timestamp: DateTime.now().toString(),
      DatabaseHelper.diraction: 'send',
      DatabaseHelper.reply: model.reply,
      DatabaseHelper.replyText: model.replyText,
      DatabaseHelper.type: model.type,
      DatabaseHelper.from: _userpeerid,
      DatabaseHelper.to: toId,
      DatabaseHelper.deliveryStatus: 'Undelivered',
      DatabaseHelper.textId: model.textId,
      DatabaseHelper.url: model.url ?? ''
    };
    final id = await _dbHelper.insert(row);
    debugPrint('inserted row id: $id');
    return id;
  }

  // void _isUserOnline() async {
  //   PreferenceConnector().setCurrentChatUserName(
  //     widget.recentchatuserdetails.name,
  //   );
  //   if (widget.rtmpeerid.isEmpty) {
  //     // debugPrint('Please input peer user id to query.');
  //     return;
  //   }
  //   try {
  //     Map<dynamic, dynamic> result =
  //         await _createClient().queryPeersOnlineStatus([widget.rtmpeerid]);
  //     // debugPrint('Query result: ' + result.toString() + widget.rtmpeerid);
  //     var clientstatus = result.values.toString();
  //     if (clientstatus == '(true)') {
  //       setState(() {
  //         onlinestatus = 'Online';
  //       });
  //     } else if (clientstatus == '(false)') {
  //       setState(() {
  //         onlinestatus = 'Offline';
  //       });
  //     }
  //   } catch (errorCode) {
  //     // debugPrint('Query error: ' + errorCode.toString());
  //   }
  // }

  void updatelocaldata(user) async {
    await _dbHelper.sendUpdate(user, DateTime.now());
    //  debugPrint('query all rows:');
  }

  var datetime = DateTime.now().toString();

  void imageapi(
      XFile image, /*String fileName,*/ String toPeerId, ChatModel model) {
    PreferenceConnector.getJsonToSharedPreferencetoken(StringConstant.loginData)
        .then((value) => {
              if (value != null)
                {
                  setState(() {
                    _loading = true;
                    _uplordstatus = 1;
                    EasyLoading.show();
                  }),
                  ApiRepository()
                      .uplordchatimage(value, image)
                      .then((value) async {
                    if (mounted) {
                      if (value != null) {
                        if (value.status == 'successfull') {
                          model.message = image.name;
                          model.url = value.body.source;
                          model.to = toPeerId;

                          AgoraRtmMessage message = AgoraRtmMessage.fromText(
                              jsonEncode(model.toJson()));
                          // if (widget.client == null) {
                          //   await _createClient();
                          // }
                          await _client.sendMessageToPeer(
                            toPeerId,
                            message,
                            true,
                            false,
                          );

                          await _sendFCMPushChat(model);
                          model.url = image.path;
                          final id = await _insertForward(model, toPeerId);
                          model.id = id.toString();
                          chatLogController.addLog(model);
                          EasyLoading.dismiss();
                          setState(() {
                            _loading = false;
                            _uplordstatus = 0;
                          });
                        } else {
                          Helper.showMessage('Unable to send ');
                          EasyLoading.dismiss();
                          setState(() {
                            _uplordstatus = 2;
                          });
                        }
                      }
                    }
                  })
                }
            });
  }

  Future<AgoraRtmClient> _createClient() async {
    try {
      _client = await AgoraRtmClient.createInstance(
          'd6306b59624c4e458883be16f5e6cbd2');
      String value = await PreferenceConnector.getJsonToSharedPreferencetoken(
          StringConstant.loginData);
      if (value != null) {
        final result = await ApiRepository().Messanger_rtmtoken(value);
        await _client.login(result.body.rtmToken, result.body.rtmUser);
      }
    } catch (_) {}
    // widget.client = await AgoraRtmClient.createInstance(appId);
    return _client;
  }

  void videoAPI(final XFile video, ChatModel model) {
    PreferenceConnector.getJsonToSharedPreferencetoken(StringConstant.loginData)
        .then((value) => {
              if (value != null)
                {
                  EasyLoading.show(),
                  setState(() {
                    _uplordstatus = 1;
                    _loading = true;
                  }),
                  ApiRepository()
                      .uplordchatimage(value, video)
                      .then((value) async {
                    if (mounted) {
                      if (value != null) {
                        if (value.status == 'successfull') {
                          var textid = model.textId;

                          model.type = 'video';
                          model.message = video.name;

                          if (_replytex != '') {
                            model.reply = 'reply';
                            model.replyText = _replytex;
                          } else {
                            model.reply = 'noreplay';
                            model.replyText = '';
                          }
                          model.url = value.body.source;
                          await _sendFCMPushChat(model);
                          AgoraRtmMessage message = AgoraRtmMessage.fromText(
                              jsonEncode(model.toJson()));
                          await _client.sendMessageToPeer(
                              widget.rtmpeerid, message, true, false);

                          model.url = video.path;
                          final id = await _insert(model);
                          model.id = id.toString();
                          chatLogController.addLog(model);
                          updatelocaldata(widget.rtmpeerid);
                          EasyLoading.dismiss();
                          setState(() {
                            debugPrint('uplordsucess');
                            _loading = false;
                            _uplordstatus = 0;
                          });
                          // });

                        } else {
                          EasyLoading.dismiss();
                          setState(() {
                            _uplordstatus = 2;
                          });
                        }
                      }
                    }
                  })
                }
            });
  }

  List<String> dataListWithCopy = ['Copy', 'Delete', 'Forward'];
  List<String> dataList1 = ['Delete', 'Forward'];

  Future<String> _popupdialog(
      String selectedmsgid, ChatModel model, int i) async {
    var hidecopy = false;
    List<String> dataList;
    if (model.type == 'doc' || model.type == 'video' || model.type == 'image') {
      hidecopy = true;
      dataList = dataList1;
    } else {
      dataList = dataListWithCopy;
    }
    return showDialog(
        context: context,
        builder: (BuildContext context) {
          return StatefulBuilder(builder: (context, refresh) {
            return AlertDialog(
                shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(30.0)),
                title: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    Text(
                      'Choose Option',
                      style: TextStyle(
                          fontSize: 2.2.h,
                          fontWeight: FontWeight.bold,
                          color: AppColors.appNewDarkThemeColor),
                    ),
                    InkWell(
                      child: Icon(
                        Icons.cancel_outlined,
                        size: 2.4.h,
                      ),
                      onTap: () {
                        Navigator.pop(context);
                      },
                    )
                  ],
                ),
                content: SizedBox(
                  width: double.minPositive,
                  child: ListView.builder(
                    shrinkWrap: true,
                    itemCount: dataList.length,
                    itemBuilder: (BuildContext context, int index) {
                      return InkWell(
                        child: Padding(
                            padding: const EdgeInsets.all(8.0),
                            child: Row(
                              mainAxisAlignment: MainAxisAlignment.spaceBetween,
                              children: [
                                Text(
                                  dataList[index],
                                  style: TextStyle(fontSize: 2.h),
                                ),
                                dataList[index] == 'Copy'
                                    ? Icon(
                                        Icons.copy,
                                        color: Colors.grey,
                                        size: 2.3.h,
                                      )
                                    : dataList[index] == 'Delete'
                                        ? Icon(
                                            Icons.delete_outline,
                                            color: Colors.grey,
                                            size: 2.5.h,
                                          )
                                        : Icon(
                                            Icons.forward,
                                            color: Colors.grey,
                                            size: 2.5.h,
                                          )
                              ],
                            )),
                        onTap: () {
                          switch (index) {
                            case 0:
                              if (hidecopy) {
                                _delete(int.parse(selectedmsgid), i);
                              } else {
                                Clipboard.setData(
                                    ClipboardData(text: model.message));
                              }
                              Navigator.of(context, rootNavigator: true)
                                  .pop('dialog');
                              break;
                            case 1:
                              if (hidecopy) {
                                forwordList(widget.userlist, model);
                              } else {
                                _delete(int.parse(selectedmsgid), i);
                              }
                              Navigator.of(context, rootNavigator: true)
                                  .pop('dialog');
                              break;
                            case 2:
                              if (hidecopy != true) {
                                forwordList(widget.userlist, model);
                              }
                              Navigator.of(context, rootNavigator: true)
                                  .pop('dialog');
                              break;
                            case 3:
                              Navigator.of(context, rootNavigator: true)
                                  .pop('dialog');
                              break;
                          }
                        },
                      );
                    },
                  ),
                ));
          });
        });
  }

  Widget images() {
    return _afile
        ? SizedBox(
            height: 20.h,
            width: double.infinity,
            child: Image.file(File(_replyImagePath),
                errorBuilder: (context, url, error) => const Icon(Icons.error,
                    size: 70,
                    color: Colors.red,
                    semanticLabel: 'image not found')),
          )
        : Text(_replytex,
            style: const TextStyle(fontSize: 14.0, color: Colors.black));
  }

  // void _fcmapicall2(String msg, String fcmtoken, image, String call_id,
  //     String type, String profileimage, String textid) {
  //   Helper.checkConnectivity().then((value) => {
  //         if (value)
  //           {
  //             ApiRepository()
  //                 .sendFCMPush(
  //                     message: call_id,
  //                     name: Logindata.name,
  //                     token: fcmtoken,
  //                     image: image,
  //                     callId: call_id,
  //                     type: type,
  //                     fcmtoken: Logindata.authToken,
  //                     userprofile: profileimage,
  //                     datetime: DateTime.now().toString(),
  //                     userpeerid: userpeerid,
  //                     senderpeerid: widget.recentchatuserdetails.peerId,
  //                     textid: textid)
  //                 .then((value) async {})
  //           }
  //         else
  //           {Helper.showNoConnectivityDialog(context)}
  //       });
  // }

  Future<void> _sendFCMPushChat(ChatModel model) async {
    if (await Helper.checkConnectivity()) {
      final value = await ApiRepository().sendChatPush(
        model: model,
        title: _loginData.name,
        receiverToken: widget.recentchatuserdetails.fcm_token,
        // image: image,
        fromPeerId: _userpeerid,
        type: 'basic_channel',
      );
      if (value != null) {
        debugPrint(value.toString());
      }
    } else {
      Helper.showNoConnectivityDialog(context);
    }

    // Helper.checkConnectivity().then((value) => {
    //       if (value)
    //         {
    //           ApiRepository()
    //               .sendChatPush(
    //             model: model,
    //             title: _loginData.name,
    //             receiverToken: widget.recentchatuserdetails.fcm_token,
    //             // image: image,
    //             fromPeerId: _userpeerid,
    //             type: 'basic_channel',
    //           )
    //               .then((value) async {
    //             if (value != null) {
    //               debugPrint(value.toString());
    //             }
    //           })
    //         }
    //       else
    //         {Helper.showNoConnectivityDialog(context)}
    //     });
  }

  void localdata() async {
    final data = await PreferenceConnector.getJsonToSharedPreferencetoken(
        StringConstant.Userdata);

    if (data != null) {
      var profileJson = jsonDecode(data.toString());
      setState(() {
        _loginData = LocalDataModal.fromJson(profileJson);
      });
    }
    final value = await PreferenceConnector.getJsonToSharedPreferenceefcmtoken(
        StringConstant.fcmtoken);
    // .then((value) => {
    //       if (value != null)
    //         {
    //           devicefcmtoken = value,
    //         }
    //     });
    if (value != null) {
      _devicefcmtoken = value;
    }

    PreferenceConnector.setJsonToSharedPreferencechatscreen(
        StringConstant.chatscreen, 'chatscreen');
  }

  // void videocallapi(String name, String id, String calltype, textid) {
  //   ApiRepository().videocallapi(name, id, Logindata.authToken).then((value) {
  //     EasyLoading.dismiss();
  //     if (value != null) {
  //       if (value.status == 'successfull') {
  //         fcmapicall2(
  //             calltype,
  //             widget.recentchatuserdetails.fcm_token,
  //             '',
  //             value.body.callId,
  //             'call_channel',
  //             widget.recentchatuserdetails.profile_image,
  //             textid);
  //         _callinsert(value.body.calleeName, calltype, 'Dilled_Call');
  //         if (calltype == 'video') {
  //           Navigator.of(context).push(
  //             MaterialPageRoute(
  //                 builder: (context) => TestLiveStream(
  //                       appid: value.body.appid,
  //                       rtmChannel: value.body.callChannel,
  //                       rtmToken: value.body.callToken,
  //                       rtmUser: value.body.calleeName,
  //                       userName: Logindata.id.toString(),
  //                       channelName: value.body.callChannel,
  //                       token: value.body.callToken,
  //                     )),
  //           );
  //         } else {
  //           Navigator.of(context).push(
  //             MaterialPageRoute(
  //                 builder: (context) => AudioCallpage(
  //                       appid: value.body.appid,
  //                       rtmChannel: value.body.callChannel,
  //                       rtmToken: value.body.callToken,
  //                       rtmUser: value.body.calleeName,
  //                       userName: Logindata.id.toString(),
  //                       channelName: value.body.callChannel,
  //                       token: value.body.callToken,
  //                     )),
  //           );
  //         }
  //       }
  //     }
  //   });
  // }

  // Future<void> _callinsert(
  //     String calleeName, String calltype, String Calldrm, String callId) async {
  //   // row to insert
  //   Map<String, dynamic> row = {
  //     DatabaseHelper.Id: null,
  //     DatabaseHelper.calleeName: calleeName,
  //     DatabaseHelper.timestamp: DateTime.now().toString(),
  //     DatabaseHelper.calltype: calltype,
  //     DatabaseHelper.Calldrm: Calldrm,
  //     DatabaseHelper.Callid: callId,
  //   };
  //   final id = await _dbHelper.callinsert(row);
  //   // debugPrint('inserted row id: $id');
  //   return id;
  // }

  void clearprefnacedata() {
    PreferenceConnector().setCurrentChatUserName('');
    PreferenceConnector.setJsonToSharedPreferencechatscreen(
        StringConstant.chatscreen, 'null');

    PreferenceConnector.getJsonToSharedPreferenceechatscreen(
            StringConstant.chatscreen)
        .then((value) => {
              if (value != null)
                {
                  // debugPrint(value + 'sdsaa'),
                }
            });
  }

  void forwordList(List<Connections> joiner, ChatModel model) {
    // dynamic json = joiner;
    String jsonArry = jsonEncode(joiner);
    List jsonData = jsonDecode(jsonArry);
    for (int i = 0; i < jsonData.length; i++) {
      _seleteduserlist.add(false);
    }
    showModalBottomSheet(
      context: context,
      backgroundColor: Colors.transparent,
      isScrollControlled: true,
      builder: (BuildContext context) {
        return StatefulBuilder(
            builder: (BuildContext context, StateSetter setState) {
          return Container(
            height: 90.h,
            margin: const EdgeInsets.symmetric(horizontal: 10),
            padding:
                const EdgeInsets.only(top: 5, bottom: 30, left: 20, right: 20),
            decoration: const BoxDecoration(
              borderRadius: BorderRadius.only(
                topLeft: Radius.circular(20),
                topRight: Radius.circular(20),
              ),
              image: DecorationImage(
                  image: AssetImage('assets/images/whitebg.png'),
                  fit: BoxFit.cover),
            ),
            child: Column(
              mainAxisAlignment: MainAxisAlignment.end,
              children: [
                SizedBox(
                  height: 1.h,
                ),
                SizedBox(
                  height: .7.h,
                  child: Container(
                    height: 3,
                    width: 80,
                    decoration: BoxDecoration(
                        color: Colors.black,
                        borderRadius: BorderRadius.circular(20)),
                  ),
                ),
                SizedBox(
                  height: 1.5.h,
                ),
                SizedBox(
                    height: 73.h,
                    child: SingleChildScrollView(
                      child: ListView.separated(
                          scrollDirection: Axis.vertical,
                          shrinkWrap: true,
                          physics: const NeverScrollableScrollPhysics(),
                          itemBuilder: (context, index) {
                            return Row(
                              mainAxisAlignment: MainAxisAlignment.spaceBetween,
                              children: [
                                Row(
                                  children: [
                                    Container(
                                      decoration: BoxDecoration(
                                        color: AppColors.addedColor,
                                        borderRadius: BorderRadius.circular(50),
                                        gradient: LinearGradient(
                                          begin: Alignment.topCenter,
                                          end: Alignment.bottomCenter,
                                          colors: [
                                            AppColors.appNewLightThemeColor,
                                            AppColors.appNewDarkThemeColor,
                                          ],
                                        ),
                                      ),
                                      child: CircleAvatar(
                                        radius: 3.h,
                                        backgroundColor: Colors.transparent,
                                        child: Center(
                                          child: Text(
                                            jsonData[index]['name'][0],
                                            textAlign: TextAlign.center,
                                            style: TextStyle(
                                                color: Colors.white,
                                                fontWeight: FontWeight.w200,
                                                fontSize: 3.h),
                                          ),
                                        ),
                                      ),
                                    ),
                                    const SizedBox(
                                      height: 10,
                                      width: 10,
                                    ),
                                    Text(
                                      '${(jsonData[index]['name']).toString()}',
                                      style: TextStyle(
                                        color: Colors.black,
                                        fontSize: 15.sp,
                                      ),
                                    ),
                                  ],
                                ),
                                Row(
                                  children: [
                                    GestureDetector(
                                        onTap: () {
                                          setState(() {
                                            if (_seleteduserlist[index] ==
                                                false) {
                                              _seleteduserlist[index] = true;
                                              rtmforwordmessage(
                                                model,
                                                joiner[index],
                                              );
                                            } else {
                                              // debugPrint('Peer ID');
                                            }
                                          });
                                        },
                                        child: _seleteduserlist[index] == true
                                            ? SvgPicture.asset(
                                                'assets/icons/radio_button_checked.svg',
                                                height: 5.h,
                                                width: 5.h,
                                              )
                                            : Image.asset(
                                                'assets/icons/radio_button_unchecked.png',
                                                height: 5.h,
                                                width: 5.h,
                                              )),
                                  ],
                                )
                              ],
                            );
                          },
                          separatorBuilder: (_, __) => SizedBox(
                                height: 1.h,
                              ),
                          itemCount: jsonData.length),
                    )),
                SizedBox(
                  height: 2.5.h,
                ),
                GestureDetector(
                    onTap: () {
                      _seleteduserlist.clear();
                      Navigator.pop(context);
                    },
                    child: Center(
                      child: Container(
                        width: 40.w,
                        height: 5.h,
                        decoration: BoxDecoration(
                          color: AppColors.addedColor,
                          borderRadius: BorderRadius.circular(10),
                          gradient: LinearGradient(
                            begin: Alignment.topCenter,
                            end: Alignment.bottomCenter,
                            colors: [
                              AppColors.appNewLightThemeColor,
                              AppColors.appNewDarkThemeColor,
                            ],
                          ),
                        ),
                        child: Center(
                          child: Padding(
                            padding: EdgeInsets.symmetric(vertical: 1.h),
                            child: Text(
                              'Done',
                              style: TextStyle(
                                color: Colors.white,
                                fontSize: 2.h,
                                letterSpacing: .5,
                                fontWeight: FontWeight.w700,
                              ),
                            ),
                          ),
                        ),
                      ),
                    )),
              ],
            ),
          );
        });
      },
    );
  }

  _progressbar(total, current, i) {
    // debugPrint(loading);
    if (_loading == true) {
      if (i != total - 1) {
        return const Icon(
          Icons.play_arrow,
          color: Colors.redAccent,
          size: 40,
        );
      } else {
        // debugPrint('123ifelse');
        return const CircularProgressIndicator(
            semanticsLabel: 'Linear progress indicator');
      }
    } else {
      return const Icon(
        Icons.play_arrow,
        color: Colors.redAccent,
        size: 40,
      );
    }
  }

  imageprogressbar(total, current, i) {
    if (_uplordstatus == 1) {
      if (i != total - 1) {
        return Container();
      } else {
        return const SizedBox(
          height: 30,
          width: 30,
          child: CircularProgressIndicator(
              strokeWidth: 1.0, semanticsLabel: 'Linear progress indicator'),
        );
      }
    } else if (_uplordstatus == 2) {
      debugPrint('here error else');
      return const Icon(
        Icons.error,
        color: Colors.redAccent,
        size: 40,
      );
    } else {
      debugPrint('here else');
      return Container(
        height: 0,
        width: 0,
      );
    }
  }

  // void replytext(ChatModel model) {
  //   // dynamic name = model.message.split('#@#&');
  //   // if (model.type == 'doc' || model.type == 'image' || model.type == 'video') {
  //   //   replytex = mode;
  //   // } else {
  //   _replytex = model.message;
  //   // }
  // }

  void rtmforwordmessage(ChatModel oldModel, Connections joiner) async {
    if (joiner.status != 'active') {
      EasyLoading.showToast(widget.recentchatuserdetails.name + ' Blocked you',
          toastPosition: EasyLoadingToastPosition.center,
          duration: const Duration(seconds: 5));
      return;
    }

    var textid = DateTime.now().millisecondsSinceEpoch.toString();
    ChatModel model = ChatModel(
        from: _userpeerid,
        to: joiner.peerId,
        message: oldModel.message,
        reply: 'forword',
        replyText: '',
        diraction: 'send',
        timestamp: DateTime.now().toString(),
        type: oldModel.type,
        url: oldModel.url,
        deliveryStatus: 'new',
        textId: textid);

    if (oldModel.type == 'image' &&
        oldModel.url != null &&
        !oldModel.url.startsWith('http')) {
      final path = XFile(oldModel.url);
      imageapi(path, joiner.peerId, model);
      updatelocaldata(widget.rtmpeerid);
    } else if (oldModel.type == 'video' || oldModel.type == 'doc') {
      AgoraRtmMessage message =
          AgoraRtmMessage.fromText(jsonEncode(model.toJson()));
      _client.sendMessageToPeer(joiner.peerId, message, true, false);
      final id = await _insertForward(model, joiner.peerId);
      model.id = id.toString();
      chatLogController.addLog(model);
      updatelocaldata(widget.rtmpeerid);
    } else {
      AgoraRtmMessage message =
          AgoraRtmMessage.fromText(jsonEncode(model.toJson()));

      _client.sendMessageToPeer(joiner.peerId, message, true, false);
      final id = await _insertForward(model, joiner.peerId);
      model.id = id.toString();
      chatLogController.addLog(model);
      updatelocaldata(widget.rtmpeerid);
    }
  }

  dynamic processedvalue = [];

  doubletick(String status, id, logindex) {
    // debugPrint('partslength' + parts.length.toString());
    if ((Chat_Screen.onlinestatus == 'Online') || status == 'delivered') {
      processedvalue.add(logindex);
      if (id != '' /*|| id !='Instance of 'Future<dynamic>''*/) {
        var val = _dbHelper.updatedeliverystatus(int.parse(id), 'delivered');
        //  widget.logController.value = [...widget.logController.value, parts];
      }
      return Icon(
        Icons.done_all_outlined,
        color: AppColors.white,
        size: 15,
      );
    } else if ((Chat_Screen.onlinestatus == 'Offline' && status == 'new') ||
        status == 'Undelivered') {
      if (processedvalue.contains(logindex)) {
        return Icon(
          Icons.done_all_outlined,
          color: AppColors.white,
          size: 15,
        );
      }
      return Icon(
        Icons.done,
        color: AppColors.white,
        size: 15,
      );
    }
  }

  Widget statusWidget() {
    return OnlineStatusView(
      transitAllowed: widget.recentchatuserdetails.transit_allowed,
      client: widget.client,
      rtmpeerid: widget.rtmpeerid,
      status: widget.status,
    );
    //   var status = '';
    //   if (widget.status != 'inactive' ||
    //       widget.status == null ||
    //       widget.recentchatuserdetails.transit_allowed != 'No') {
    //     status = onlinestatus;
    //   } else if (widget.recentchatuserdetails.transit_allowed == 'No' &&
    //       widget.status == 'active') {
    //     status = 'You are Blocked';
    //   } else {
    //     status = 'Block';
    //   }
    //   return Text(
    //     '${status}',
    //     style: TextStyle(fontSize: 2.0.h, color: Colors.white),
    //   );
    // }
  }
}

class CustomShape extends CustomPainter {
  final Color bgColor;

  CustomShape(this.bgColor);

  @override
  void paint(Canvas canvas, Size size) {
    var paint = Paint()..color = bgColor;
    var path = Path();
    path.lineTo(-5, 0);
    path.lineTo(0, 10);
    path.lineTo(5, 0);
    canvas.drawPath(path, paint);
  }

  @override
  bool shouldRepaint(CustomPainter oldDelegate) {
    return false;
  }
}
